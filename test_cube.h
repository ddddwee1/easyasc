DEvent<PIPE_MTE2, PIPE_MTE1> _tmp_devent_ready_l1_0;
DEvent<PIPE_MTE1, PIPE_MTE2> _tmp_devent_valid_l1_0;
DEvent<PIPE_M, PIPE_MTE1> _tmp_devent_valid_l0_0;
DEvent<PIPE_MTE1, PIPE_M> _tmp_devent_ready_l0_0;
DEvent<PIPE_FIX, PIPE_M> _tmp_devent_valid_fix_0;
DEvent<PIPE_M, PIPE_FIX> _tmp_devent_ready_fix_0;
GlobalTensor<half> x;
x.SetGlobalBuffer((__gm__ half*) x_);
GlobalTensor<half> y;
y.SetGlobalBuffer((__gm__ half*) y_);
workspace = ShiftAddr<half>(workspace, M*N, offset);
GlobalTensor<half> vv;
vv.SetGlobalBuffer((__gm__ half*) workspace);
DBuff<half, TPosition::A1> l1q;
DBuff<half, TPosition::A1> l1k;
DBuff<half, TPosition::A2> l0a;
DBuff<half, TPosition::B2> l0b;
DBuff<float, TPosition::CO1> l0c;
int cnt = 0;
int cnt1 = 0;
int cnt2 = 0;
int ubcnt = 0;
float val = 1.0;
int m_per_core = CeilDiv(M, GetBlockNum());
int m1 = m_per_core*get_block_idx();
int m2 = Min(m1 + m_per_core, M);
for (int m = m1; m < m2; m += 128) {
    _tmp_devent_valid_l1_0.wait();
    GM2L1_ND2NZ(l1q.get(cnt), x[K*m], 128, K, K, 128);
    _tmp_devent_ready_l1_0.set();
    _tmp_devent_ready_l1_0.wait();
    _tmp_devent_valid_l0_0.wait();
    L0NZ2ZZ(l0a.get(cnt), l1q.get(cnt)[1024], 64, K, 128, K);
    L0NZ2NZ(l0b.get(cnt), l1k.get(cnt), 64, K, 128, K);
    _tmp_devent_ready_l0_0.set();
    _tmp_devent_ready_l0_0.wait();
    _tmp_devent_valid_fix_0.wait();
    MMAD(l0c.get(cnt), l0a.get(cnt), l0b.get(cnt), 64, K, 64, true);
    _tmp_devent_ready_fix_0.set();
    _tmp_devent_ready_fix_0.wait();
    L0C2GM_NZ2ND(y, l0c.get(cnt), 1, N, N, 128);
    cnt = cnt + 1;
    _tmp_devent_ready_l1_0.set();
    _tmp_devent_ready_l0_0.set();
    _tmp_devent_ready_fix_0.set();
}
